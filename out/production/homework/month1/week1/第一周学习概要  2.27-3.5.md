# 2.27 周一

### 上午：

[**节02_Java开发环境基础配置**](http://47.97.82.68:8080/49th/SE01/V1/02_Java开发环境基础配置.html?ws=none&cf=off)

​	project与module

​	包的概念-文件夹

[**节03_IDEA常用操作和软件推荐**](http://47.97.82.68:8080/49th/SE01/V1/03_IDEA常用操作和软件推荐.html?ws=none&cf=off)

​	IDEA快捷键--Alt + Enter（改错）--Ctrl + Alt + L（代码格式化）

### 下午：

**[git的使用](http://47.97.82.68:8080/49th/Java线上环境安装说明.html?ws=none&cf=off#git的使用)**

​	gitee的使用

[**节05_Java变量概述与使用**](http://47.97.82.68:8080/49th/SE01/V1/05_Java变量概述与使用.html?ws=none&cf=off)

​	数据类型：基本数据类型（8种）+引用数据类型（string）

​	标识符：类名（包括后面会学习的接口名、注解名等）使用大驼峰。

​					变量和方法的命名标识符应该使用小驼峰命名法。

​	 				包名：以反转公司的域名作为开头，全部小写字母

​	变量：不要一行定义多个变量

​				两个字符串的内容是否一致，不能使用“==”号！！用 s1.equals(s2);

​				浮点数表示有效数字的位数有限，故精度受限。			

# 2.28 周二

### 上午：

9:20—10:00     

​	鸡汤

10:00—11:50  

​	**[05_Java变量概述与使用](http://47.97.82.68:8080/49th/SE01/V1/05_Java变量概述与使用.html?ws=none&cf=off#基本数据类型的数据类型转换)**

​	数据类型转换：自动类型(从小范围到大范围)+强制类型

​	tips：想直接输出,可以用".sout"   或   ".soutv"回车

​			  想用变量接收,可以用".var"回车  或  快捷键ctrl+alt+V

​	[**节06_Java运算符**](http://47.97.82.68:8080/49th/SE01/V1/06_Java运算符.html?ws=none&cf=off)[**节06_Java运算符**](http://47.97.82.68:8080/49th/SE01/V1/06_Java运算符.html?ws=none&cf=off)

​	三目运算符 (b > c) ? b : c  若真执行b，否则执行c

​	[**节07_Scanner键盘录入**](http://47.97.82.68:8080/49th/SE01/V1/07_Scanner键盘录入.html?ws=none&cf=off)

​	混用两种Scanner方法时，出现空的解决方法:＋sc.nextLine();过滤回车

​	[**节08_Java转义字符**](http://47.97.82.68:8080/49th/SE01/V1/08_Java转义字符.html?ws=none&cf=off)

​	\b 退格  \n换行  \r回车  \t间隔

### 下午：

14:20-15:20

​	[**节02_选择结构**](http://47.97.82.68:8080/49th/SE01/V2/02_选择结构.html?ws=none&cf=off)

​	if、switch（每个分支的取值，只能是固定的且离散的）

​	[**节03_循环结构**](http://47.97.82.68:8080/49th/SE01/V2/03_循环结构.html?ws=none&cf=off)

​	while、for、do while（先执行再说）

​	[**节04_跳转控制关键字**](http://47.97.82.68:8080/49th/SE01/V2/04_跳转控制关键字.html?ws=none&cf=off)

​	break、continue、return



15:35-16:35

​	 [**节01_方法的概述**](http://47.97.82.68:8080/49th/SE01/V3/01_方法的概述.html?ws=none&cf=off)

​	在同一类中,所有修饰符列表中有static的方法，都可直接用方法名互相调用



16:50-17:50

​	方法的使用细节问题：

​		方法的实参数据类型和形参数据类型保不需要完全保持一致,只需要保持兼容即可

​		同理返回值类型&引用数据类型

​	main方法详解：

​		main方法是JVM调用的

​		能够影响外界方法调用的是形参的数据类型,而不是形参的名字

​	提取方法的快捷键ctrl + alt + m

# 3.1 周三

### 上午：

9:30-10:20

​	[**节02_方法的重载**](http://47.97.82.68:8080/49th/SE01/V3/02_方法的重载.html?ws=none&cf=off)

​	方法重载：

​		允许一个类中，多个方法拥有相同的名字，此时形参列表必须不同

​	就近原则： 

​		方法在调用时,实参数据类型自动类型转换到形参（int->double）,该实参就允许传入方法，有可能出现一次方法调用,多个方法匹配的情况，此时就要遵循Java设计原则的"就近原则"



10:35-11:50

​	[**节03_Junit单元测试**](http://47.97.82.68:8080/49th/SE01/V3/03_Junit单元测试.html?ws=none&cf=off)

​	含义：可以在同一个类中实现多个main方法的效果,是很好的测试工具。

​	使用：@Test  ------ alt + 回车 

```java
public void 方法名(){
// 方法体
}
```

​	tip：不建议再写main方法

​			格式固定,不可以修改，必须是空参方法

​			注解是和class同等级别的数据类型

​	全限定类名(全类名): 包名 + 简单类名  ---@org.junit.Test  （org.junit)+(Test)

​	[**节04_IDEA的Debug模式**](http://47.97.82.68:8080/49th/SE01/V3/04_IDEA的Debug模式.html?ws=none&cf=off)

​	打断点

​	阴影行：表示接下来马上要执行的代码

​	debug模式下,variables窗口下的黄色p(parameter)图标,：表示方法的形式参数

​	断点上右键就可以设置当前断点的条件，用于循环

​	[**节01_数组的基本概念**](http://47.97.82.68:8080/49th/SE01/V4/01_数组的基本概念.html?ws=none&cf=off)

​	数组优缺点：优----效率高，随机访问

​						 缺----数组长度不可变

​	tip：实际开发中，使用JAVA集合体系中的ArrayList，

​			可自动扩容,底层实现是数组,带有随机访问的新的数据类型

​			通过“数组元素拷贝”方式实现的“数组扩容”

### 下午：

​	复习：Java基础和流程控制

​	预习：JVM内存模型，数组的常见操作等。

​	sourcetree连接github仓库要有ssh令牌！！！

# 3.2 周四

### 上午：

9:30-10:20

​	 [**节02_数组的基本使用**](http://47.97.82.68:8080/49th/SE01/V4/02_数组的基本使用.html?ws=none&cf=off)

​	数组初始化：静态----数据类型[] 数组名 = new 数据类型[]{元素1,元素2...};

​						 动态---数据类型[] 数组名 = new 数据类型[数组长度];

​						 数组的初始化一旦完成，其长度不能改变	

10:35-11:50

​	[**节03_JVM内存模型**](http://47.97.82.68:8080/49th/SE01/V4/03_JVM内存模型.html?ws=none&cf=off)

​	1.JVM栈：

​			局部变量和"方法调用"同生共死,这就是局部变量的生命周期

​	2.引用数据类型

​		引用数据类型变量 = 引用（在栈上开辟空间,存储引用数据类型变量的"名字"） + 对象（在堆上开辟空间,存储引用数据类型变量的对象）

​		"=="连接两个引用时,比较的是地址

​	3.堆和栈中内容的区别

​			栈上存储局部变量,局部变量必须手动赋值

​			堆上存储对象,对象中的元素具有默认值 （分别为。。。。）

### 下午：

14:30-15:20

​	[**节04_数组操作中的异常**](http://47.97.82.68:8080/49th/SE01/V4/04_数组操作中的异常.html?ws=none&cf=off)

​	1.常见的异常：

​			数组下标越界异常

​			空指针异常：针对所有引用数据类型 + 两种解决异常的思路

​			数组长度为0  VS  数组是null  VS  数组未初始化



15:35-16:35 + 16:50-17:50

​	[**节05_数组的常见操作**](http://47.97.82.68:8080/49th/SE01/V4/05_数组的常见操作.html?ws=none&cf=off)	

​	1.数组遍历：

​			Arrays.tostring(数组名)

​			处理长度为0和null的数组： if (arr == null || arr.length == 0)

​			增强for循环：不能修改任何元素的取值 + 直接遍历元素，而不是下标

​	2.找最大最小值：假设第一个元素为max or min， 依次比较

​	3.数组逆序：

​			把下标为"i"和"length-1-i"元素互换

​			只需要交换一半数组的元素

​	4.增删改查：

​			create（上课详细讲解过）    retrieve  update  delete

​	5.数组拷贝：代码 _4operation._4.copy 里面

​			要求真正删除（增加）某一个元素,但该元素可能不唯一

​			创建一个新数组,新数组的长度 = 老数组的长度 -（+） 被删除元素的个数

​			然后拷贝赋值，注意需过滤掉被删除的元素（continue）



# 3.3 周五

### 上午：

​	9:30-10:20

​	1.equals方法:

​			比较两个字符串的内容，内容相同返回true，内容不同返回false

​			避免空指针异常：左右两边，有一个引用确定不是null,把它放在左边



​	10:35-11:50

​	[**节06_可变参数**](http://47.97.82.68:8080/49th/SE01/V4/06_可变参数.html?ws=none&cf=off)

​	可变参数：

​			"数据类型... 变量名" 整体，本质是对应数据类型的数组

​			一个方法只能有一个可变长参数，

​			可变长参数必须是该方法的最后一个参数。



​	[**节07_方法的传参问题**](http://47.97.82.68:8080/49th/SE01/V4/07_方法的传参问题.html?ws=none&cf=off)

​		Java只有值传递，但引用的拷贝和原先引用仍然指向同一个对象



​	[**节03_二维数组的进阶操作**](http://47.97.82.68:8080/49th/SE01/V5/03_二维数组的进阶操作.html?ws=none&cf=off)

​	杨辉三角：

​	二维数组的遍历



### 下午：

14:30-15:20

​	[**节04_递归的基本使用**](http://47.97.82.68:8080/49th/SE01/V5/04_递归的基本使用.html?ws=none&cf=off)

​	1.递归 = 调用自身的语句（递归体）+ 递归停止的条件

​	2.栈溢出：递归深度超出栈内存的大小（工作2000年就可以在北京买房啦）

​	stackoverflow.com 程序员问答网站

​	[**节05_递归的进阶练习**](http://47.97.82.68:8080/49th/SE01/V5/05_递归的进阶练习.html?ws=none&cf=off)

​	递归求解问题：

​		核心点 = 递归体 + 递归的出口
​		思想：分解

​	汉诺塔：将(N-1)个盘子从塔1移到塔2  ------>   将最大的盘子移到塔3



15:35-16:35

## 终于！！！JavaSE第二部分：面向对象

​	[**节02_对象和类**](http://47.97.82.68:8080/49th/SE02/V1/02_对象和类.html?ws=none&cf=off)

​	1.概念		

​			对象：程序世界中的个体，是具体的

​			面向对象：程序开发的核心是对象,程序的开发围绕对象而展开.

​			类：创建对象的模板就是类，是抽象的

​	2.类的语法：

​			[类修饰符列表] class 类名{ }

​			一个Java文件中只能定义一个public修饰的类

​			成员变量：

​				在类的全局生效，整个类中的成员方法都可访问

​				成员变量不能直接在同类下的static方法中访问

​			成员方法：定义在类的成员位置,修饰符列表中不存在static关键字

​	3.对象语法： 类名 对象名 = new 类名();



16:50-17:50

​	[**节03_引用数据类型**](http://47.97.82.68:8080/49th/SE02/V1/03_引用数据类型.html?ws=none&cf=off)

​	1.定义一个类=定义一个全新的数据类型，即引用数据类型

​	2.引用数据类型VS基本数据类型：

​			JVM在使用引用数据类型之前，需要“类加载”认识了解的过程

​			基本数据类型则不用，因为它在jvm中已经预先定义

​	3.About类加载：

​			概念：从一个类的class字节码，通过IO流的形式，读进JVM内存（方法区）开始的

​			懒加载：类/引用必须使用时，才会加载一个类，破不得已

​			类加载的时机：必须要类加载某个类的场景

​				new某个类的对象 or 启动main方法 or etc...

​			!!!!类加载次数：一次程序的运行中，某个类的类加载至多只有一次

​	[**节04_局部变量和成员变量**](http://47.97.82.68:8080/49th/SE02/V1/04_局部变量和成员变量.html?ws=none&cf=off)

​	1.成员变量的赋值：

​			创建对象之后赋值：

​			创建对象过程中赋值：

​				默认初始化 or 显示赋值

​	2.局部变量 VS 成员变量

​			定义位置 / 内存中位置 / 生命周期 / 有无默认值 / 作用范围  均不同



# 3.4 周六

### 上午：

​	9:30-10:20

​	[**节05_this关键字**](http://47.97.82.68:8080/49th/SE02/V1/05_this关键字.html?ws=none&cf=off)

​	概念：this指向当前对象（调用该成员方法的对象），本质是引用

​	使用场景：成员方法的方法体中,this.成员变量名 = 成员变量名 （同名局部变量）

​	作用：成员方法中存在同名局部变量，需要区分时，必须写this

​	static方法：无隐式传参 (this)，没有当前对象，需new一个对象，才能访问

​	成员方法：具有this传参,指向当前对象,成员方法之间可以无条件互相调用



​	10:35-11:50

​	[**节06_构造方法**](http://47.97.82.68:8080/49th/SE02/V1/06_构造方法.html?ws=none&cf=off)

​	1.构造器语法：

​			[访问修饰符 public]  类名  (形参列表)  {  //构造方法体  }

​			无返回值类型 / 无返回值 / 不能使用return关键字

​			隐含this传参，其方法体类似成员方法的方法体

​	2.构造器作用：

​			给成员变量赋值 (new对象过程中，被JVM自动调用 )

​			tip：JVM创建对象，构造器不管创建对象

​	3.类中定义构造器：

​			若类中没有构造器，则Java编译器会默认加上无参构造

​			同一类中，不同的构造器间是方法的重载

​	4.使用细节：

​			new 类名 （实参列表）;  指明JVM调用哪一个构造器，构造器不能手动调用

​			若一个类已经有一个构造器，则Java编译器不会默认提供无参

​			对Java的任何一个类，一定有一个构造器

​			快捷键：Alt + insret 按住Ctrl 可以选择

​	5.构造器赋值：给成员变量赋值的手段

​			默认初始化(头) ------> 显示赋值 ------>构造器赋值 (尾)

​	6.this关键字在构造器中：

​			独特用法：可表示调用同类中的其他构造器 this (实参列表 );

​			也可指向当前对象

​			表示调用其它构造器的this语句必须处在构造器代码的第一行

​	7.tip：

​			构造方法的方法栈帧名字为: <init> + 行数 + 类名

​			new对象过程中,构造器中有赋值以及各种结构的执行顺序是:

​				默认初始化-->构造器方法栈帧进栈--->成员变量的显示赋值-->new对象的构造器代码--->构造器代码执行完毕，new对象过程中的赋值结束。	