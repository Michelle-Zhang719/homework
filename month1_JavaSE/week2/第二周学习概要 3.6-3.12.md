# 3.6 周一

### 上午：

9:30-10:20 +10:35-11:50

​	[**节07_小练习和小问题**](http://47.97.82.68:8080/49th/SE02/V1/07_小练习和小问题.html?ws=none&cf=off)

​	练习面向对象思想：pvz + 亚索 + 读程序

​	值传递：Java方法得到的是传入的实参变量的拷贝,而不是实参变量本身

​	构造方法必须和类名一致，普通方法不建议和类名一致（警告⚠）

### 下午：

14:30-15:20 + 15:35-16:35

​	[**节08_static关键字**](http://47.97.82.68:8080/49th/SE02/V1/08_static关键字.html?ws=none&cf=off)

​	1.静态成员变量：（eg：球队工资帽）

​			用static关键字修饰

​			是一种被全体对象共享，属于类的变量 (全局变量)

​			存储在一片能够被全体对象所共享的内存区域

​	2.语法：

​			静态成员变量： [访问权限修饰符] static 数据类型 变量名;

​			静态成员方法： [访问权限修饰符] static 返回值类型 方法名(形参列表){ }

​	3.静态成员的使用：

​			静态成员变量：有默认初始化 / 使用 “类名 . ” 访问 / 属于类，不需创建对象使用

​			静态成员方法：无需创建对象，可通过 “类名.” 直接调用/

​	4.原理：

​			static修饰的成员，称为静态成员，包括静态成员变量和静态成员方法

​			类加载完毕，静态成员就存在，就可直接使用，不用通过创建对象使用

​			静态成员变量的赋值： 默认初始化 ---- >  显示赋值/静态代码块

​	5.类加载时机：

​			(第一次) new对象 / 启动main方法 /  (第一次) 访问类的静态成员（方法和变量）

​			类加载只有一次，类的静态成员变量只有一份，静态方法被所有类对象共享

​			静态成员方法不是在类加载过程中，会自动被调用的方法！！！

​	6.static与非static比较

​			成员变量 VS 静态成员变量：

​				成员所属 / 在内存中位置 / 内存中出现的时机 / 调用方式 / 内存中个数

​			成员方法 VS 静态成员方法：与类加载时机 和 创建对象与否有关

|                  | 同类中的普通成员 | 同类中静态成员 |
| :--------------: | :--------------: | :------------: |
|   **成员方法**   |    可直接访问    |   可直接访问   |
| **静态成员方法** |   不可直接访问   |   可直接访问   |

​	7.static关键字使用场景

​			静态成员变量：

​					属于全体对象所共享 / 在整个类全局独一份的

​			静态成员方法：

​					当一个类中全部都是静态成员方法时，此类称为工具类（数组工具类Arrays...）

​					静态成员方法不调用不执行

​	8.注意事项：

​			一个类中，静态方法无法直接调用非静态的方法和属性，也不能使用this，super关键字



​	[**节09_匿名对象**](http://47.97.82.68:8080/49th/SE02/V1/09_匿名对象.html?ws=none&cf=off)

​	1.概念： new 类名();

​			在创建对象时，就没有引用指向的对象

​			匿名对象必须就在创建的同时使用它

​	2.使用：

​			某个对象，仅使用一次时

16:50-17:50

​	[**节10_代码块**](http://47.97.82.68:8080/49th/SE02/V1/10_代码块.html?ws=none&cf=off)

​	1.概念：

​			类体后面跟的"{}"不是代码块

​			局部代码块 / 构造~ / 静态~ / 同步~

​	2.构造代码块语法：

​			代码块当中的位置是局部位置 / 在局部位置定义的变量是局部变量

​	3.构造代码块的作用：

​			随着构造器的执行而执行，用在创建对象过程当中，给成员变量赋值！

​			创建对象过程中，成员变量赋值方式：

​					默认初始化--->显示赋值/构造代码块--->构造器

​	4.构造代码块原理 & 创建对象过程中碰到的结构的执行顺序

​			在同一类中，构造代码块总是先于它的构造器而执行。

# 3.7 周二

### 上午：

9:30-10:20 

​	5.构造代码块使用注意事项

​			代码块中的位置是局部位置，定义的变量是局部变量

​			可以使用this关键字，指向当前对象

​			成员变量、成员方法的作用范围：成员方法 + 构造代码块 + 构造方法

​	6.构造代码块的使用场景：

​			某些代码，在new对象过程中，需要每个构造器都执行时

​			给成员变量赋值很复杂时（需要算法...）

​	7.静态代码块：

​		概念：static{ }  定义的是局部变量，不是静态变量！！！

​		作用：类加载过程中被调用，给静态成员变量赋值

​		静态成员变量赋值的手段：默认初始化--->显示赋值/静态代码块（按照代码顺序）

​		原理：类加载从上到下

​		使用场景：

​			复杂的静态成员变量的赋值 

​			某代码在类的全局，只运行一次（因为类加载只有一次）

​			测试类加载的顺序

​	8.tip：init 构造方法栈帧

​			clinit 类加载的最后一步

​			方法名 正在执行的方法

​	9.类加载细节

​			类初始化步骤完成之前，这个类就可以创建对象了。创建对象，不依赖于完成类加载（初始化）。

​		三道读程序题!

10:35-11:50

​	[**节11_导包**](http://47.97.82.68:8080/49th/SE02/V1/11_导包.html?ws=none&cf=off)

​	1.package关键字

​	2.全限定类名：包名+类名

​	3.import关键字

​			搜索机制：编译器可同包下搜索类，不同包时，需要手动导包

​			智能导入：import + 包名.*;

​				如果同包下有同名类则不会导入！

​			静态导入：	

​				import static 全限定类名.静态成员;

​				导入的是静态成员（变量和方法）

### 下午：

14:30-15:20

​	[**节12_访问权限修饰符**](http://47.97.82.68:8080/49th/SE02/V1/12_访问权限修饰符.html?ws=none&cf=off)

​	1.访问级别：依赖包实现

​			private：最严格：尽在当前类中可以访问

​			访问权限修饰符为空：宽松：允许跨类访问，但只能在同包下访问

​			protected： 更宽松：允许挎包访问，但在该类的子类中才能访问

​			public：最宽松：无所谓那个包哪个类，可任意访问

​	2.分类

​			单独定义的类，访问权限修饰符只有两种：public + 默认的访问级别	                                                                                                                                                    

​			嵌套定义的类 (内部类) ，有四种访问权限

​			类中结构 (类中成员、静态成员、构造器)的访问级别：四种皆可

​	3.作用：

​			工具类必须私有化无参构造器，确保使用者不会new对象

​			类中对外提供功能的方法，权限为public，中间方法，private权限

​	4.单例模式：

​			多线程/单线程

15:35-16:35 + 16:50-17:50

​	[**节13_OOP**](http://47.97.82.68:8080/49th/SE02/V1/13_OOP.html?ws=none&cf=off)

​	面向过程 VS 面向对象



# 3.8 周三

### 上午：

9:30-10:20

​	[**节01_封装的基础理解**](http://47.97.82.68:8080/49th/SE02/V2/01_封装的基础理解.html?ws=none&cf=off)

​	实现：私有化成员变量，然后提供Getter、Setter方法

10:35-11:50

​	[**节01_继承的引入**](http://47.97.82.68:8080/49th/SE02/V3/01_继承的引入.html?ws=none&cf=off)

​	使用关键字 extends

​	[**节02_继承中两个类的关系**](http://47.97.82.68:8080/49th/SE02/V3/02_继承中两个类的关系.html?ws=none&cf=off)

​	从属关系

​	[**节03_引用数据类型的类型转换**](http://47.97.82.68:8080/49th/SE02/V3/03_引用数据类型的类型转换.html?ws=none&cf=off)

​	1.转换的是引用的数据类型，不是对象的类型

​	2.前提：发生在具有父子关系的两个类之间

​	3.分类：

​			自动类型转换：子类引用转为父类  / 从下至上

​			强制类型转换：子类类型 对象名 = (子类类型)父类引用  / 向下转型

​	[**节04_继承的优缺点**](http://47.97.82.68:8080/49th/SE02/V3/04_继承的优缺点.html?ws=none&cf=off)

​	子类可以在继承父类成员方法之后，对方法进行重写



# 3.9 周四

### 上午：

9:30-10:20

​	[**节05_继承层次**](http://47.97.82.68:8080/49th/SE02/V3/05_继承层次.html?ws=none&cf=off)

​	1.单继承：一个类只能有一个直接父类

​	2.继承层次：

​			概念：继承层次 / 祖先类 / 继承链

​			Java中一个类仍然可以有很多个"间接父类"

​			Object类：是Java所有类的顶层祖先类

​			不在同一条继承链中的类，没有任何关系

​	[**节06_继承的限制**](http://47.97.82.68:8080/49th/SE02/V3/06_继承的限制.html?ws=none&cf=off)

​		子类会继承父类的私有成员，但不能访问，因为没有访问权限

​		构造器不能被继承

​		子类能够使用父类的静态成员，并不意味着继承



10:35-11:50

​	[**节07_protected访问权限**](http://47.97.82.68:8080/49th/SE02/V3/07_protected访问权限.html?ws=none&cf=off)

​	1.不同包子类能够访问

​			在不同包下，必须在子类中，创建子类自身对象，才能够访问它从父类那里继承过来的protected成员

 

### 下午：

14:30-15:20

​	[**节08_子类对象的初始化问题**](http://47.97.82.68:8080/49th/SE02/V3/08_子类对象的初始化问题.html?ws=none&cf=off)

​	1.子类对象创建时，父类的成员从何而来，父类成员变量的如何赋值

​	2.子类对象的初始化流程：

​			a.类加载：触发子类类加载，会优先类加载它的父类，从最顶层父类开始

​			b.创建对象：只会创建子类对象本身，不会创建父类对象

​			c.子类对象的区域划分：

​				子类对象的两个区域 = 自身成员区域 + 父类成员区域

​				super指向子类对象中的父类区域，可近似看成指向一个父类对象。

​			d.成员变量的赋值:

​					父类构造器，先于子类构造器被执行完毕保证的

​					父子类成员变量的赋值顺序：先父后子

​					new子类对象的过程中，从顶层父类开始，向下执行构造器

​			e.隐式子类对象初始化 VS 显式子类对象初始化 

​					子类构造器中，隐含调用父类的无参构造方法的语句 super ();

​					在子类构造器的第一行，用  super(参数);  明确指出调用父类的某个构造方法来完成父类成员变量的赋值

​	3.super关键字

​			this在当前类中不受访问权限控制 / super访问父类成员，受访问权限控制

​			super： 不是一个引用，不指向一个父类对象，指向子类对象中的父类区域

15:35-16:35

​	[**节09_继承中的属性隐藏**](http://47.97.82.68:8080/49th/SE02/V3/09_继承中的属性隐藏.html?ws=none&cf=off)

​	1.属性隐藏：父类的同名成员变量被子类同名成员变量隐藏

​	2.对象名.成员变量的访问机制：都是根据引用的数据类型来决定的

​			访问范围：由引用的数据类型决定 / 编译器在编译代码时就决定了访问范围

​			访问结果：由 引用的数据类型 来决定的



16:50-17:50

​	[**节10_继承中的方法覆盖**](http://47.97.82.68:8080/49th/SE02/V3/10_继承中的方法覆盖.html?ws=none&cf=off)

​	1.对象名.成员方法的访问机制：

​			访问范围：由 引用的数据类型 来决定

​			访问结果：根据 对象的实际类型 来决定

​	2.方法覆盖：

​		a.父类的同名成员方法，只要创建子类对象，无法用 "对象名." 访问到

​		b.在子类中，能够改写父类成员方法的内容

​		c.子类中重写的方法： 

​				访问权限---可宽松 

​				返回值类型----若父类方法的返回值类型是父类类型，则子类重写的方法可返回子类类型，其余要一致

​				方法名：严格保持一致

​				形参列表：保持严格一致

​	3.方法重写 vs 方法重载



# 3.10 周五

### 上午：

9:30-10:20

​	[**节11_final关键字**](http://47.97.82.68:8080/49th/SE02/V3/11_final关键字.html?ws=none&cf=off)

​	1.修饰符： 可修饰class类 / 方法 / 变量（成员~、静态成员~、局部~）

​	2.final修饰类：此类不能被继承

​	3.final修饰方法：此方法无法被重写，但可被继承

​	4.final修饰变量：被final修饰的变量，是自定义常量 / 单词全大写，两个单词间用"_"隔开

​			a. 局部变量：方法体中 / 方法的形参列表中

​			b.成员变量： 成员常量的赋值，有且必须有一次（在创建对象过程中）  = 显示赋值 + 构造代码块 + 构造器

​			c.静态成员变量：全局常量 （在类加载过程中）赋值 = 显示赋值 + 静态代码块

​			d.引用数据类型：修饰的是引用，对象中成员变量的取值仍可修改

​			

10:35-11:50

​	[**节01_多态的引入**](http://47.97.82.68:8080/49th/SE02/V4/01_多态的引入.html?ws=none&cf=off)

​	1.多态：同一个父类引用，指向不同子类对象时，调用同名成员方法，得到的行为不同

​	2.发生条件：继承  / 重写  / 父类引用指向子类对象	

​	[**节02_多态的访问特征**](http://47.97.82.68:8080/49th/SE02/V4/02_多态的访问特征.html?ws=none&cf=off)

​	1.成员变量的访问：没有多态现象

​			父子类存在同名成员变量，表现出属性的隐藏。

​			编译时（访问范围）看左边，运行时（访问结果）还看左边。

​	2.成员方法的访问特征：

​			编译（访问范围）看左边，运行时（调用结果）看右边

​	[**节03_多态的优缺点和向下转型**](http://47.97.82.68:8080/49th/SE02/V4/03_多态的优缺点和向下转型.html?ws=none&cf=off)

​	缺点：子类独有的成员是无法使用父类引用访问的

​	引用数据类型的强制类型转换：父类的引用转换成子类的引用

​			子类类名 对象名 = （子类类名）父类引用

​			引用所指向的真实对象，得是子类对象或本身

​	instanceof关键字：

​			引用名 instanceof 类名

​			判断引用指向的对象，是否为后面类名的子类对象或对象本身

### 下午：

14:30-15:20

​	[**节04_多态的总结和练习**](http://47.97.82.68:8080/49th/SE02/V4/04_多态的总结和练习.html?ws=none&cf=off)

​	读程序题 X2

15:35-16:35

​	[**节01_抽象类**](http://47.97.82.68:8080/49th/SE02/V5/01_抽象类.html?ws=none&cf=off)

​	1.抽象类：为派生其他类的父类，不能创建对象实例

​			语法：[修饰符列表] **abstract** class 类名{ //类体 }

​	2.抽象方法：必须写在一个抽象类中

​			[修饰符列表] abstract 返回值类型 方法名(形参列表);  / 分号！！

​	3.抽象类特点：实际上和普通类能够定义的成员是一样的，多了一个抽象方法

​			final和abstract在修饰类时是冲突的

​			抽象类虽然不能创建对象，但也有构造器，有代码块

​			抽象方法：作用："占位"  普通类继承该抽象类，都必须实现该抽象方法

​	4.抽象类的子类：

​			普通类：必须实现所有的抽象方法

​			抽象类：抽象子类可以自由选择实现



16:50-17:50

​	[**节02_接口**](http://47.97.82.68:8080/49th/SE02/V5/02_接口.html?ws=none&cf=off)

​	1.定义：表示功能的扩展 / 不受单继承限制 / 强调行为的抽象

​			访问修饰符：public + 默认缺省

​			接口中可以定义抽象方法

​			接口的实现：使用 implements 关键字

​			普通类实现接口必须实现所有抽象方法

​	2.接口优点：表示对功能的扩展，它只关注行为，不关注属性

​	3.接口特点：

​			public static final都是隐含的

​			接口没有构造方法，没有构造代码块，也没有静态代码块

​			接口的子类：

​				普通类实现接口，必须实现所有的抽象方法。
​				抽象类实现接口，按需实现抽象方法

​			继承（extends）是不能跨越种族的，类和类继承，接口和接口继承，接口和类之间没有继承关系

​			实现（implements），必须发现在类与接口之间，接口和类是没有任何关系的

# 3.11 周六

### 上午：

9:30-10:20 + 10:35-11:50

​	4.接口的默认方法：default 返回值类型 方法名(形参列表) {}

​			访问权限修饰符默认是public

​			接口中一旦新增任何方法，子类都必须实现它，默认方法不用

​	5.接口的静态方法：static 返回值类型 方法名(形参列表){}

​			访问权限修饰符默认是public

​			调用方式是用接口名.静态方法名

​			只能自己用，不能用实现类类名调用

​	6.接口 VS 抽象类

​	7.方法的形参和返回值类型

​		a.方法传值 & 方法的返回值：不一定要求数据类型完全一致

​				基本类型 : 存在自动类型提升

​				引用类型：存在自动向上转型，可返回子类对象(类/抽象类/接口)

​		b.方法重写中的返回值类型问题

​				基本类型和void：必须保持一模一样，不存在类型提升

​				引用类型：不必保持一模一样，存在自动向上转型(类/抽象类/接口)

​	8.链式调用：本质：方法的返回值是一个对象